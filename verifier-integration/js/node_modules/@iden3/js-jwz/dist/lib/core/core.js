"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Core = void 0;
const cross_sha256_1 = require("cross-sha256");
const util_1 = require("./util");
class Core {
    static intToBytes(int) {
        return Uint8Array.from((0, util_1.toLittleEndian)(int, 31));
    }
    static checkChecksum(bytes) {
        const { typ, genesis, checksum } = Core.decomposeBytes(bytes);
        if (!checksum.length ||
            JSON.stringify(Uint8Array.from([0, 0])) === JSON.stringify(checksum)) {
            return false;
        }
        const c = Core.calculateChecksum(typ, genesis);
        return JSON.stringify(c) === JSON.stringify(checksum);
    }
    static decomposeBytes(b) {
        const offset = 2;
        const len = b.length - offset;
        return {
            typ: b.slice(0, offset),
            genesis: b.slice(offset, len),
            checksum: b.slice(-offset),
        };
    }
    static calculateChecksum(typ, genesis) {
        const toChecksum = new Uint8Array([...typ, ...genesis]);
        const s = toChecksum.reduce((acc, cur) => acc + cur, 0);
        const checksum = [];
        checksum[0] = s >> 8;
        checksum[1] = s & 0xff;
        return Uint8Array.from(checksum);
    }
    static hashBytes(str) {
        const hash = new cross_sha256_1.sha256().update(str).digest();
        return new Uint8Array(hash);
    }
    static hexToBytes(str) {
        const buffer = Buffer.from(str, 'hex');
        return Uint8Array.from(buffer);
    }
    static bytesToHex(bytes) {
        const hex = [];
        for (let i = 0; i < bytes.length; i++) {
            const current = bytes[i] < 0 ? bytes[i] + 256 : bytes[i];
            hex.push((current >>> 4).toString(16));
            hex.push((current & 0xf).toString(16));
        }
        return hex.join('');
    }
}
exports.Core = Core;
//# sourceMappingURL=core.js.map