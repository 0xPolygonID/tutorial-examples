"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Id = void 0;
// eslint-disable-next-line camelcase
const base58_js_1 = require("base58-js");
const core_1 = require("./core");
const util_1 = require("./util");
// ID is a byte array with
// [  type  | root_genesis | checksum ]
// [2 bytes |   27 bytes   | 2 bytes  ]
// where the root_genesis are the first 28 bytes from the hash root_genesis
class Id {
    constructor(typ, genesis) {
        const checksum = core_1.Core.calculateChecksum(typ, genesis);
        this._bytes = Uint8Array.from([...typ, ...genesis, ...checksum]);
    }
    static fromBytes(bytes) {
        const { typ, genesis } = core_1.Core.decomposeBytes(bytes);
        return new Id(typ, genesis);
    }
    string() {
        return (0, base58_js_1.binary_to_base58)(this._bytes);
    }
    bytes() {
        return this._bytes;
    }
    bigInt() {
        return (0, util_1.fromLittleEndian)(this._bytes);
    }
    equal(id) {
        return JSON.stringify(this._bytes) === JSON.stringify(id.bytes);
    }
    static idFromBytes(b) {
        const bytes = b ?? Uint8Array.from([]);
        if (bytes.length !== 31) {
            throw new Error('IDFromBytes error: byte array incorrect length');
        }
        if (bytes.every((i) => i === 0)) {
            throw new Error('IDFromBytes error: byte array empty');
        }
        const id = Id.fromBytes(bytes);
        if (!core_1.Core.checkChecksum(bytes)) {
            throw new Error('IDFromBytes error: checksum error');
        }
        return id;
    }
    static idFromString(s) {
        const bytes = (0, base58_js_1.base58_to_binary)(s);
        return Id.idFromBytes(bytes);
    }
    static idFromInt(bigInt) {
        const b = core_1.Core.intToBytes(bigInt);
        return Id.idFromBytes(b);
    }
}
exports.Id = Id;
//# sourceMappingURL=id.js.map