"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjToArray = exports.toBigEndian = exports.bufToBn = exports.toLittleEndian = exports.fromBigEndian = exports.fromLittleEndian = void 0;
function fromLittleEndian(bytes) {
    const n256 = BigInt(256);
    let result = BigInt(0);
    let base = BigInt(1);
    bytes.forEach((byte) => {
        result += base * BigInt(byte);
        base = base * n256;
    });
    return result;
}
exports.fromLittleEndian = fromLittleEndian;
function fromBigEndian(bytes) {
    return fromLittleEndian(bytes.reverse());
}
exports.fromBigEndian = fromBigEndian;
function toLittleEndian(bigNumber, len = 32) {
    const n256 = BigInt(256);
    const result = new Uint8Array(len);
    let i = 0;
    while (bigNumber > BigInt(0)) {
        result[i] = Number(bigNumber % n256);
        bigNumber = bigNumber / n256;
        i += 1;
    }
    return result;
}
exports.toLittleEndian = toLittleEndian;
function bufToBn(u8) {
    const hex = [];
    u8.forEach(function (i) {
        let h = i.toString(16);
        if (h.length % 2) {
            h = '0' + h;
        }
        hex.push(h);
    });
    return BigInt('0x' + hex.join(''));
}
exports.bufToBn = bufToBn;
function toBigEndian(bigNumber) {
    return toLittleEndian(bigNumber).reverse();
}
exports.toBigEndian = toBigEndian;
function ObjToArray(json) {
    const str = JSON.stringify(json, null, 0);
    const ret = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
        ret[i] = str.charCodeAt(i);
    }
    return ret;
}
exports.ObjToArray = ObjToArray;
//# sourceMappingURL=util.js.map